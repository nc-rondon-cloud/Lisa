"""
LISA Diary System

Manages structured Markdown documentation of all ML decisions, experiments, and insights.
Every entry documents reasoning, decisions, and outcomes.
"""

import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional
from .config import config


class Diary:
    """Manages LISA's diary entries for documenting ML workflow"""

    ENTRY_TYPES = [
        'eda',
        'experiment',
        'training',
        'evaluation',
        'stopping_decision',
        'hyperparameter_tuning',
        'feature_engineering',
        'data_preprocessing',
        'model_comparison',
        'final_report'
    ]

    def __init__(self, diary_path: Optional[Path] = None):
        """
        Initialize Diary

        Args:
            diary_path: Path to diary directory. If None, uses config.
        """
        if diary_path is None:
            self.diary_path = config.get_path('diary')
        else:
            self.diary_path = Path(diary_path)

        # Create diary directory if it doesn't exist
        self.diary_path.mkdir(parents=True, exist_ok=True)

    def write_entry(
        self,
        entry_type: str,
        title: str,
        content: Dict[str, Any],
        experiment_id: Optional[str] = None
    ) -> Path:
        """
        Write a diary entry

        Args:
            entry_type: Type of entry (eda, experiment, training, etc.)
            title: Brief title for the entry
            content: Dictionary with sections to include
            experiment_id: Optional MLflow run ID

        Returns:
            Path to the created entry file

        Content dict can include:
            - context: Why this action was taken
            - decision: What was decided
            - results: What happened
            - next_steps: What to do next
            - artifacts: List of related files/models
            - metrics: Dictionary of metrics
            - reasoning: Detailed reasoning
        """
        if entry_type not in self.ENTRY_TYPES:
            raise ValueError(f"Invalid entry_type: {entry_type}. Must be one of {self.ENTRY_TYPES}")

        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{timestamp}_{entry_type}_{self._slugify(title)}.md"
        filepath = self.diary_path / filename

        # Build markdown content
        md_content = self._build_markdown(entry_type, title, content, experiment_id)

        # Write file
        with open(filepath, 'w') as f:
            f.write(md_content)

        return filepath

    def _build_markdown(
        self,
        entry_type: str,
        title: str,
        content: Dict[str, Any],
        experiment_id: Optional[str]
    ) -> str:
        """Build markdown content from dictionary"""
        lines = []

        # Header
        lines.append(f"# {entry_type.upper()}: {title}")
        lines.append("")
        lines.append(f"**Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"**Entry Type**: {entry_type}")

        if experiment_id:
            lines.append(f"**Experiment ID**: `{experiment_id}`")

        lines.append("")
        lines.append("---")
        lines.append("")

        # Main sections
        section_order = [
            ('context', '## Context'),
            ('reasoning', '## Reasoning'),
            ('decision', '## Decision'),
            ('results', '## Results'),
            ('metrics', '## Metrics'),
            ('artifacts', '## Artifacts'),
            ('issues', '## Issues'),
            ('next_steps', '## Next Steps'),
            ('conclusions', '## Conclusions')
        ]

        for key, header in section_order:
            if key in content and content[key]:
                lines.append(header)
                lines.append("")

                value = content[key]

                if isinstance(value, dict):
                    # Format as bullet list or code block
                    if key == 'metrics':
                        for metric_name, metric_value in value.items():
                            lines.append(f"- **{metric_name}**: {metric_value}")
                    else:
                        lines.append("```yaml")
                        for k, v in value.items():
                            lines.append(f"{k}: {v}")
                        lines.append("```")
                elif isinstance(value, list):
                    for item in value:
                        lines.append(f"- {item}")
                else:
                    lines.append(str(value))

                lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*Generated by LISA (Learning Intelligent Software Agent)*")

        return "\n".join(lines)

    def _slugify(self, text: str) -> str:
        """Convert title to filename-safe slug"""
        # Simple slugify: lowercase, replace spaces with underscores, remove special chars
        import re
        text = text.lower()
        text = re.sub(r'[^\w\s-]', '', text)
        text = re.sub(r'[-\s]+', '_', text)
        return text[:50]  # Limit length

    def search_entries(
        self,
        query: Optional[str] = None,
        entry_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Path]:
        """
        Search diary entries

        Args:
            query: Text to search for in filenames or content
            entry_type: Filter by entry type
            limit: Maximum number of results

        Returns:
            List of Path objects to matching entries
        """
        entries = []

        for entry_file in sorted(self.diary_path.glob("*.md"), reverse=True):
            # Filter by entry type
            if entry_type:
                if f"_{entry_type}_" not in entry_file.name:
                    continue

            # Filter by query
            if query:
                # Search in filename
                if query.lower() in entry_file.name.lower():
                    entries.append(entry_file)
                    continue

                # Search in content
                try:
                    content = entry_file.read_text()
                    if query.lower() in content.lower():
                        entries.append(entry_file)
                except Exception:
                    pass

            else:
                entries.append(entry_file)

            if len(entries) >= limit:
                break

        return entries

    def get_latest_entry(self, entry_type: Optional[str] = None) -> Optional[Path]:
        """
        Get the most recent diary entry

        Args:
            entry_type: Optional filter by entry type

        Returns:
            Path to latest entry, or None if no entries found
        """
        entries = self.search_entries(entry_type=entry_type, limit=1)
        return entries[0] if entries else None

    def read_entry(self, entry_path: Path) -> str:
        """Read and return content of a diary entry"""
        return entry_path.read_text()

    def summarize_session(self, output_path: Optional[Path] = None) -> str:
        """
        Create a summary of all diary entries in the current session

        Args:
            output_path: Optional path to write summary. If None, returns string.

        Returns:
            Markdown summary of all entries
        """
        entries = sorted(self.diary_path.glob("*.md"))

        if not entries:
            return "No diary entries found."

        summary_lines = []
        summary_lines.append("# LISA Experiment Session Summary")
        summary_lines.append("")
        summary_lines.append(f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        summary_lines.append(f"**Total Entries**: {len(entries)}")
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")

        # Group by entry type
        entries_by_type = {}
        for entry in entries:
            # Extract type from filename
            for entry_type in self.ENTRY_TYPES:
                if f"_{entry_type}_" in entry.name:
                    if entry_type not in entries_by_type:
                        entries_by_type[entry_type] = []
                    entries_by_type[entry_type].append(entry)
                    break

        # Summarize each type
        for entry_type in self.ENTRY_TYPES:
            if entry_type in entries_by_type:
                summary_lines.append(f"## {entry_type.upper()} Entries ({len(entries_by_type[entry_type])})")
                summary_lines.append("")

                for entry in entries_by_type[entry_type]:
                    # Extract timestamp and title from filename
                    summary_lines.append(f"- **{entry.stem}**")

                summary_lines.append("")

        summary = "\n".join(summary_lines)

        if output_path:
            with open(output_path, 'w') as f:
                f.write(summary)

        return summary

    def __repr__(self) -> str:
        return f"Diary(path={self.diary_path})"
